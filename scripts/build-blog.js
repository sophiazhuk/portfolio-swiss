/**
 * Blog Build Script
 * 
 * This script scans all markdown files in /content/blog/,
 * extracts frontmatter metadata, and generates src/data/blogPosts.js
 * 
 * Run before deploying: npm run blog:build
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import matter from 'gray-matter';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const BLOG_DIR = path.join(__dirname, '../content/blog');
const OUTPUT_FILE = path.join(__dirname, '../src/data/blogPosts.js');

/**
 * Read all markdown files and extract frontmatter
 */
function generateBlogPosts() {
  const files = fs.readdirSync(BLOG_DIR).filter(file => 
    file.endsWith('.md') && file !== 'README.md'
  );

  const posts = files.map(filename => {
    const filePath = path.join(BLOG_DIR, filename);
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    const { data } = matter(fileContent);

    // Validate required fields
    const requiredFields = ['slug', 'title', 'date', 'tags', 'excerpt'];
    const missingFields = requiredFields.filter(field => !data[field]);
    
    if (missingFields.length > 0) {
      console.warn(`${filename} is missing fields: ${missingFields.join(', ')}`);
    }

    return {
      slug: data.slug || '',
      title: data.title || '',
      date: typeof data.date === 'string' ? data.date : data.date?.toISOString().split('T')[0] || '',
      tags: data.tags || [],
      excerpt: data.excerpt || '',
    };
  });

  // Sort by date (newest first)
  posts.sort((a, b) => new Date(b.date) - new Date(a.date));

  // Generate the JavaScript file content
  const output = `// Central blog data model for Blog page and blog routes
// This file is auto-generated by scripts/build-blog.js
// DO NOT EDIT MANUALLY - Edit the markdown files in /content/blog/ instead
// Run 'npm run blog:build' to regenerate this file

/**
 * @typedef {Object} BlogPost
 * @property {string} slug - URL-friendly id used in route e.g., /blog/{slug}
 * @property {string} title - Display title
 * @property {string} date - ISO date string (YYYY-MM-DD)
 * @property {string[]} tags - Array of tags for filtering (e.g., ["project", "music", "ideas", "vacation"])
 * @property {string} excerpt - Brief preview text for the blog card
 */

/** @type {BlogPost[]} */
export const blogPosts = ${JSON.stringify(posts, null, 2)};

/**
 * Get all unique tags from blog posts
 * @returns {string[]} Array of unique tags
 */
export const getAllTags = () => {
  const tagSet = new Set();
  blogPosts.forEach(post => {
    post.tags.forEach(tag => tagSet.add(tag));
  });
  return Array.from(tagSet).sort();
};

/**
 * Filter blog posts by tag
 * @param {string} tag - Tag to filter by
 * @returns {BlogPost[]} Filtered blog posts
 */
export const getPostsByTag = (tag) => {
  if (!tag || tag === "all") return blogPosts;
  return blogPosts.filter(post => post.tags.includes(tag));
};

/**
 * Get a single blog post by slug
 * @param {string} slug - Blog post slug
 * @returns {BlogPost | undefined} Blog post or undefined if not found
 */
export const getPostBySlug = (slug) => {
  return blogPosts.find(post => post.slug === slug);
};
`;

  fs.writeFileSync(OUTPUT_FILE, output, 'utf-8');
  
  console.log('Blog posts generated successfully!');
  console.log(`Found ${posts.length} blog post(s):`);
  posts.forEach(post => {
    console.log(`   - ${post.title} (${post.slug})`);
  });
}

// Run the script
try {
  generateBlogPosts();
} catch (error) {
  console.error('Error generating blog posts:', error);
  process.exit(1);
}
